sql alchemy notes

sqlalchemy sql expression language is different from sqlalchemy ORM
lazy connecting - db engine doesnt actually connect to db until the first query is made.
Declarative - create classes that have directives that describe database tables
	there is a base class which has a catalog of classes and tables relative to it. this is declarative_base() class. Base = declarative_base()
	NEED __tablename__ and atleast 1 column
	when class is constructed, Declarative replaces all Column objects with special Python accessors known as descriptors. 

Table object represents specific information about a db table 
	Declarative makes the Table object for us. User.__table__

When you declare a table, Declarative uses a python metaclass to do a bunch of stuff for you:
	MetaData objects: (User.metadata)
		Table object is a type of Metadata
	created Mapper object - 


Sesssion object is ORM's handle to the db
session doesnt open any connections upon creation. It gets connections from pool of connections that Engine has. Session holds the connection until it has commited all changes to the db or when this session is closed.

add a new object to a session. Then, you must flush it. Until you flush the object, it is not in the db. NOTE: if you add a object and then query it, the object will be flushed before the query automatically. 

session.dirty - shows objects that have been modified
session.new - shows all objects that still need to be flushed

commit() - flushes changes to db. THEN, commit's changes to db.
	flush puts into db (thus now object has primary key)
	commit saves db. (thus object will be available during next session)
once commited, all future things that this session does will go through being put in session.dirty and then be flushed and then be commited into the db. A db transaction is the full adding to db, and then committing. A new transaction is made each time you commit. Each time, a new connection is attained as well.

session regets the data from the db the first time a object is used after every transaction
	objects states:
		transient: instance not in session and not saved in db. it has no db identity. only thing that this object has going for it is that it's class is mapped to something in the mapper
		pending:when you add() to a session, object is pending. does not touch db until flush
		persistent: present in session and inside db. You do so by actually flushing yourself. OR making a object pending and then querying for it (automatically gets flushed).
		detached: saved into db. commit() does this. 
	can get state of object via inspect(my_obj).transient == True 

querying results is like calling a create_list type function on a object. can do stuff like 
for instance in session.query(User)
or 
for name, fullname in session.query(User.name, User.fullname)



