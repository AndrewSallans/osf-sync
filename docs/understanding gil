GIL: Global Interpreter Lock
This is specific to python

!!!LOCK!!!

GIL is used to serialize access to interpreter internals from different threads
	this means that you access interpreter internals one by one, even if you are working from multiple threads
on multi-core systems: multiple threads can't effectively use multiple cores.
	THUS, this is why people hate pythons

Python threads are REAL system threads
	fully managed by the OS
	python Thread class just makes a new thread and then runs it's run() function. 


Inside interpreter there is a global variable that points to whatever thread is currently running. Operations in the interpreter expect this variable to know which thread we are working on

when a thread runs, it holds onto the gil. When the thread blocks for i/o, it releases the gil. Other threads can run while this gil is released. 

EXAMPLE: I have 2 threads. Thread 1 is polling api. While 1 is running, it has lock. When it is going to do io, it releases GIL (global interpreter lock). At this time, thread 2 can also run.
	???? I thought threads ran concurrently?????

After every 100 ticks, you 'check'. A check does 2 things:
	1) in the main thread ONLY, signal handlers(ctrl-c) will execute if there are any more pending...??????
		signal handlers only run in mainthread
	2) release and reacquire GIL.
This second bullet point explains how you get multiple threads running at 'once'. What you actually have is that at each tick, you release the GIL and thus allow other threads to run.

ticks are approximate 1 os instruction

when switching from a thread to another, a thread signals the OS which then signals the other thread. However, the OS thus controls how much time it takes to switch threads.
